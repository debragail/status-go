diff --git c/whisper/whisperv6/api.go w/whisper/whisperv6/api.go
index 2de99f293..28086e75e 100644
--- c/whisper/whisperv6/api.go
+++ w/whisper/whisperv6/api.go
@@ -289,6 +289,10 @@ func (api *PublicWhisperAPI) Post(ctx context.Context, req NewMessage) (hexutil.
 	if err != nil {
 		return nil, err
 	}
+	env.Expiry = uint32(api.w.GetCurrentTime().Add(time.Second * time.Duration(params.TTL)).Unix())
+	if err := env.Seal(params); err != nil {
+		return nil, err
+	}
 
 	// send to specific node (skip PoW check)
 	if len(req.TargetPeer) > 0 {
diff --git c/whisper/whisperv6/envelope.go w/whisper/whisperv6/envelope.go
index c42d1fa8a..bcab5b5ea 100644
--- c/whisper/whisperv6/envelope.go
+++ w/whisper/whisperv6/envelope.go
@@ -64,11 +64,10 @@ func (e *Envelope) rlpWithoutNonce() []byte {
 // included into an envelope for network forwarding.
 func NewEnvelope(ttl uint32, topic TopicType, msg *sentMessage) *Envelope {
 	env := Envelope{
-		Expiry: uint32(time.Now().Add(time.Second * time.Duration(ttl)).Unix()),
-		TTL:    ttl,
-		Topic:  topic,
-		Data:   msg.Raw,
-		Nonce:  0,
+		TTL:   ttl,
+		Topic: topic,
+		Data:  msg.Raw,
+		Nonce: 0,
 	}
 
 	return &env
diff --git c/whisper/whisperv6/message.go w/whisper/whisperv6/message.go
index 2d4e86244..c91496820 100644
--- c/whisper/whisperv6/message.go
+++ w/whisper/whisperv6/message.go
@@ -253,12 +253,7 @@ func (msg *sentMessage) Wrap(options *MessageParams) (envelope *Envelope, err er
 	if err != nil {
 		return nil, err
 	}
-
-	envelope = NewEnvelope(options.TTL, options.Topic, msg)
-	if err = envelope.Seal(options); err != nil {
-		return nil, err
-	}
-	return envelope, nil
+	return NewEnvelope(options.TTL, options.Topic, msg), nil
 }
 
 // decryptSymmetric decrypts a message with a topic key, using AES-GCM-256.
diff --git c/whisper/whisperv6/whisper.go w/whisper/whisperv6/whisper.go
index eb637b4ca..2be6a8c0f 100644
--- c/whisper/whisperv6/whisper.go
+++ w/whisper/whisperv6/whisper.go
@@ -92,6 +92,8 @@ type Whisper struct {
 	envelopeTracer EnvelopeTracer // Service collecting envelopes metadata
 
 	envelopeFeed event.Feed
+
+	timeSource func() time.Time // source of time for whisper
 }
 
 // New creates a Whisper client ready to communicate through the Ethereum P2P network.
@@ -110,6 +112,7 @@ func New(cfg *Config) *Whisper {
 		p2pMsgQueue:   make(chan *Envelope, messageQueueLimit),
 		quit:          make(chan struct{}),
 		syncAllowance: DefaultSyncAllowance,
+		timeSource:    time.Now,
 	}
 
 	whisper.filters = NewFilters(whisper)
@@ -215,6 +218,16 @@ func (whisper *Whisper) APIs() []rpc.API {
 	}
 }
 
+// SetTimeSource sets time source used by whisper for envelopes time and expiration logic.
+func (whisper *Whisper) SetTimeSource(timeSource func() time.Time) {
+	whisper.timeSource = timeSource
+}
+
+// GetCurrentTime returns current time.
+func (whisper *Whisper) GetCurrentTime() time.Time {
+	return whisper.timeSource()
+}
+
 // RegisterServer registers MailServer interface.
 // MailServer will process all the incoming messages with p2pRequestCode.
 func (whisper *Whisper) RegisterServer(server MailServer) {
@@ -829,7 +842,7 @@ func (whisper *Whisper) runMessageLoop(p *Peer, rw p2p.MsgReadWriter) error {
 // appropriate time-stamp. In case of error, connection should be dropped.
 // param isP2P indicates whether the message is peer-to-peer (should not be forwarded).
 func (whisper *Whisper) add(envelope *Envelope, isP2P bool) (bool, error) {
-	now := uint32(time.Now().Unix())
+	now := uint32(whisper.timeSource().Unix())
 	sent := envelope.Expiry - envelope.TTL
 
 	if sent > now {
@@ -988,7 +1001,7 @@ func (whisper *Whisper) expire() {
 	whisper.statsMu.Lock()
 	defer whisper.statsMu.Unlock()
 	whisper.stats.reset()
-	now := uint32(time.Now().Unix())
+	now := uint32(whisper.timeSource().Unix())
 	for expiry, hashSet := range whisper.expirations {
 		if expiry < now {
 			// Dump all expired messages and remove timestamp
